'''Utility to work with IPv6 addresses'''

def to_ip_num(ip: str) -> int:
    if ip.startswith('[') and ip.endswith(']'):
        ip = ip[1:-1]
    
    if ip.startswith(':'):
        ip = '0' + ip
    if ip.endswith(':'):
        ip += '0'
    
    raw_ip_segs = ip.split(':')
    num_ip_segs = []
    double_colon_used = False
    for raw_segment in raw_ip_segs:
        if raw_segment == '':
            assert not double_colon_used
            for _ in range(7):
                num_ip_segs.append(-1) # Placeholder for 0 to be autogenerated
            double_colon_used = True
        else:
            num_ip_segs.append(int(raw_segment, 16))

    assert len(num_ip_segs) >= 8 and len(num_ip_segs) <= 8 + 6
    # Ensure as many -1 entries left as need to be replaced with 0
    while -1 in num_ip_segs and len(num_ip_segs) > 8:
        num_ip_segs.pop(num_ip_segs.index(-1))
    assert len(num_ip_segs) == 8
    # Fill :: with 0s
    for i in range(len(num_ip_segs)):
        if num_ip_segs[i] == -1:
            num_ip_segs[i] = 0
    
    for segment in num_ip_segs:
        assert segment >= 0x0000 and segment <= 0xFFFF
    
    raw_ip_number = num_ip_segs[0] << 16*7 | num_ip_segs[1] << 16*6 | num_ip_segs[2] << 16*5 |  num_ip_segs[3] << 16*4 | \
         num_ip_segs[4] << 16*3 |  num_ip_segs[5] << 16*2 |  num_ip_segs[6] << 16*1 |  num_ip_segs[7]
    return raw_ip_number

def to_ip_str(ip_num: int) -> str:
    assert(ip_num >= 0 and ip_num < 2**128)
    ip_segs = (
        (ip_num >> 16*7) & 0xFFFF,
        (ip_num >> 16*6) & 0xFFFF,
        (ip_num >> 16*5) & 0xFFFF,
        (ip_num >> 16*4) & 0xFFFF,
        (ip_num >> 16*3) & 0xFFFF,
        (ip_num >> 16*2) & 0xFFFF,
        (ip_num >> 16*1) & 0xFFFF,
        (ip_num >> 16*0) & 0xFFFF
    )

    # Find zero sequences
    zero_ranges = []
    i = 0
    while i < len(ip_segs):
        if ip_segs[i] == 0:
            start = i
            end = i + 1
            while i + 1 < len(ip_segs):
                if ip_segs[i+1] == 0:
                    i += 1
                    end += 1
                else:
                    break
            zero_ranges.append((start, end))
            i = end
        else:
            i += 1

    ip_str_segs = list(map(lambda seg: hex(seg)[2:], ip_segs))
    
    # Remove digits from longest zero sequence
    if len(zero_ranges) > 0:
        biggest_range = 0
        biggest_range_index = 0
        for i, zero_range in enumerate(zero_ranges):
            if zero_range[1] - zero_range[0] > biggest_range:
                biggest_range = zero_range[1] - zero_range[0]
                biggest_range_index = i
        
        biggest_zero_range = zero_ranges[biggest_range_index]
        for i in range(biggest_zero_range[0], biggest_zero_range[1]):
            ip_str_segs[i] = ''

    # Prepare for display
    res = ':'.join(ip_str_segs)
    while ':::' in res:
        res = res.replace(':::', '::')
    return res


class IPv6:
    def __init__(self, ip: str, netmask: str=None):
        if not netmask and '/' in ip:
            ip, netmask = ip.split('/')
            netmask = '/' + netmask
        elif not netmask and ' ' in ip:
            ip, netmask = ip.split(' ')
        
        self.setIp(ip)
        self.setNetmask(netmask)
    
    def setIp(self, ip: str):
        self.ip_num = to_ip_num(ip)

    def ip(self) -> str:
        return to_ip_str(self.ip_num)

    def setNetmask(self, netmask: str):
        if not netmask:
            self.net_bit_count = 128
            return
        
        assert netmask.startswith('/')
        
        bit_count = int(netmask[1:])
        assert bit_count >= 0 and bit_count <= 128
        self.net_bit_count = bit_count

    def netmaskNum(self):
        net_count = self.net_bit_count
        host_count = 128 - net_count
        return int('1'*net_count + '0'*host_count, 2)

    def netmaskIp(self) -> str:
        return to_ip_str(self.netmaskNum())
    
    def netmaskWildcard(self) -> str:
        return '/%d' % self.net_bit_count

    def __repr__(self) -> str:
        return 'IPv6(\'%s\', \'%s\')' % (self.ip(), self.netmaskWildcard())

    def __str__(self) -> str:
        return self.ip() + self.netmaskWildcard()
    
    def totalIpsCount(self) -> int:
        return int('1' * (128 - self.net_bit_count), 2) + 1

    def firstIp(self) -> str:
        return to_ip_str(self.ip_num & self.netmaskNum())

    def lastIp(self) -> str:
        return to_ip_str( (self.ip_num & self.netmaskNum()) | (self.totalIpsCount() - 1) )

    def first(self) -> 'IPv6':
        return IPv6(self.firstIp(), self.netmaskWildcard())

    def last(self) -> 'IPv6':
        return IPv6(self.lastIp(), self.netmaskWildcard())

    def modifiedNetmask(self, change: int) -> 'IPv6':
        try:
            assert(self.net_bit_count < 128)  # /32 is not subnettable

            host_count = 128 - self.net_bit_count
            net_part = ((self.netmaskNum() & self.ip_num) >> host_count) + change
            host_part = self.ip_num & ~self.netmaskNum()
            
            next_num = ((net_part) << host_count) | host_part
            return IPv6(to_ip_str(next_num), self.netmaskWildcard())
        except AssertionError:
            return None

    def nextSubnet(self) -> 'IPv6':
        return self.modifiedNetmask(1)

    def prevSubnet(self) -> 'IPv6':
        return self.modifiedNetmask(-1)
    
    def isFirst(self) -> bool:
        return (self.ip_num & ~self.netmaskNum()) == 0

    def isLast(self) -> bool:
        return (self.ip_num & ~self.netmaskNum()) == (self.totalIpsCount() - 1)

    def modifiedPrefix(self, new_ip_prefix: 'IPv6') -> 'IPv6':
        '''
        Create a new IP based on this non-prefix part and the given
        ip with the new ip prefix.
        The length of the prefix is determined by the given IPs subnet
        '''
        new_ip_prefix = new_ip_prefix.first()
        non_prefix_num = int('0'*new_ip_prefix.net_bit_count + '1'*(128-new_ip_prefix.net_bit_count), 2) & self.ip_num

        return IPv6(to_ip_str(new_ip_prefix.ip_num | non_prefix_num))

    def __eq__(self, other: 'IPv6') -> bool:
        if not isinstance(other, IPv6):
            return False
        return self.ip_num == other.ip_num and self.net_bit_count == other.net_bit_count
